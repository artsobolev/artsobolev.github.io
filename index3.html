<!DOCTYPE html>
<html lang="en">
<head>
  <title>Index – Page 3 – B.log</title>
  <meta charset="utf-8" />

  <meta property="twitter:card" content="summary" />
  <meta name="twitter:site" content="@art_sobolev" />
  <meta property="og:title" content="Index – Page 3 – B.log" />
  <meta property="og:description" content="Personal blog of Artem Sobolev, a Machine Learning professional with particular interest in Probabilistic Modeling, Bayesian Inference, Deep Learning, and beyond" />

  <link rel="shortcut icon" href="/favicon.ico"/>

  <link rel="stylesheet" type="text/css" href="/theme/css/default.css" />
  <link rel="stylesheet" type="text/css" href="/theme/css/syntax.css" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:,b" />
  <script type="text/javascript">
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        macros: {
	  E: '\\mathop{\\mathbb{E}}'
	}
      },
      svg: {
        fontCache: 'global'
      }
    };
  </script>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
    <header>
      <hgroup>
        <h1><a href="/">B.log</a></h1>
        <h2>Random notes mostly on Machine Learning</h2>
      </hgroup>
    </header>
    <nav>
        <menu>
          <a href="/">Home</a>
          <a href="/pages/about.html">About me</a>
          <a href="http://feeds.feedburner.com/barmaley-exe-blog-feed">RSS feed</a>
        </menu>
    </nav>
    <section>

    <article>
        <header>
            <h3><a href="/posts/2014-08-01-gnu-parallel.html">Exploiting Multiple Machines for Embarrassingly Parallel Applications</a></h3>
            <time>August 1, 2014</time>
        </header>

        <section><p>During work on my machine learning project I was needed to perform some quite computation-heavy calculations several times — each time with a bit different inputs. These calculations were CPU and memory bound, so just spawning them all at once would just slow down overall running time because of increased amount of context switches. Yet running 4 (=number of cores in my CPU) of them at a time (actually, 3 since other applications need CPU, too) should speed it up.</p>
<p>Fortunately, I have an old laptop with 2 cores as well as an access to somewhat more modern machine with 4 cores. That results in 10 cores spread across 3 machines (all of`em have some version of GNU Linux installed). The question was how to exploit such a treasury.</p>
</section>
    </article>

    <hr/>

    <article>
        <header>
            <h3><a href="/posts/2014-05-01-on-sorting-complexity.html">On Sorting Complexity</a></h3>
            <time>May 1, 2014</time>
        </header>

        <section><p>It's well known that lower bound for sorting problem (in general case) is
 $\Omega(n \log n)$. The proof I was taught is somewhat involved and is
based on paths in "decision" trees. Recently I've discovered an
information-theoretic approach (or reformulation) to that proof. </p>
</section>
    </article>

    <hr/>

    <article>
        <header>
            <h3><a href="/posts/2013-05-23-js-namespaced-methods.html">Namespaced Methods in JavaScript</a></h3>
            <time>May 23, 2013</time>
        </header>

        <section><p>Once upon a time I was asked (well, actually <a href="http://habrahabr.ru/qa/7130/" title="Javascript: String.prototype.namespace.method и this / Q&A / Хабрахабр">a question</a> wasn't for me only, but for whole habrahabr's community) is it possible to implement namespaced methods in JavaScript for built-in types like:</p>
<div class="highlight"><pre><span></span><code><span class="mf">5.</span><span class="p">.</span><span class="nx">rubish</span><span class="p">.</span><span class="nx">times</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// this function will be called 5 times</span>
<span class="w">  </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;Hi there!&quot;</span><span class="p">);</span>
<span class="p">});</span>

<span class="s2">&quot;some string&quot;</span><span class="p">.</span><span class="nx">hask</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nx">c</span><span class="p">.</span><span class="nx">hask</span><span class="p">.</span><span class="nx">code</span><span class="p">();</span><span class="w"> </span><span class="p">});</span>
<span class="c1">// equivalent to</span>
<span class="s2">&quot;some string&quot;</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nx">c</span><span class="p">.</span><span class="nx">charCodeAt</span><span class="p">();</span><span class="w"> </span><span class="p">});</span>

<span class="s2">&quot;another string&quot;</span><span class="p">.</span><span class="nx">algo</span><span class="p">.</span><span class="nx">lcp</span><span class="p">(</span><span class="s2">&quot;annotation&quot;</span><span class="p">);</span><span class="w"> </span>
<span class="c1">// returns longest common prefix of two strings</span>
</code></pre></div>

<p>As you can see at the link, it's possible using ECMAScript 5 features. And that's how:</p>
</section>
    </article>

    <hr/>

    <article>
        <header>
            <h3><a href="/posts/2013-03-30-crazy-expression-parsing.html">Crazy Expression Parsing</a></h3>
            <time>March 30, 2013</time>
        </header>

        <section><p>Suppose we have an expression like <code>(5+5 * (x^x-5 | y &amp;&amp; 3))</code> and we'd like to get some computer-understandable representation of that expression, like:</p>
<p><code>ADD Token[5] (MUL Token[5] (AND (BIT_OR (XOR Token[x] (SUB Token[x] Token[5])) Token[y]) Token[3])</code></p>
<p>In case if you don't know how to do that or are looking for the solutin right now, you should know that I'm not going to present a correct solution. This post is just a joke. You should use either a <a href="http://en.wikipedia.org/wiki/Shunting-yard_algorithm" title="Shunting-yard algorithm — Wikipedia">Shunting-yard algorithm</a> or a <a href="http://en.wikipedia.org/wiki/Recursive_descent_parser">recursive descent parser</a>.</p>
<p>So if you're ready for madness... Let's go!</p>
</section>
    </article>

    <hr/>

    <article>
        <header>
            <h3><a href="/posts/2013-03-29-cpp-11-memoization.html">Memoization Using C++11</a></h3>
            <time>March 29, 2013</time>
        </header>

        <section><p>Recently I've read an article <a href="http://john-ahlgren.blogspot.ru/2013/03/efficient-memoization-using-partial.html" title="John Ahlgren: Efficient Memoization using Partial Function Application">Efficient Memoization using Partial Function Application</a>. Author explains function memoization using partial application. When I was reading the article, I thought "Hmmm, can I come up with a more general solution?" And as suggested in comments, one can use variadic templates to achieve it. So here is my version.</p>
</section>
    </article>

    <hr/>

    <article>
        <header>
            <h3><a href="/posts/2013-02-10-std-vector-growth.html">Resizing Policy of std::vector</a></h3>
            <time>February 10, 2013</time>
        </header>

        <section><p>Sometime ago when Facebook opensourced their <a title="Folly is an open-source C++ library developed and used at Facebook" href="https://github.com/facebook/folly">Folly library</a> I was reading their docs and found <a title="folly/FBvector.h documentation" href="https://github.com/facebook/folly/blob/master/folly/docs/FBVector.md">something interesting</a>. In section "Memory Handling" they state <blockquote>In fact it can be mathematically proven that a growth factor of 2 is rigorously the worst possible because it never allows the vector to reuse any of its previously-allocated memory</blockquote>I haven't got it first time. Recently I recalled that article and decided to deal with it. So after reading and googling for a while I finally understood the idea, so I'd like to say a few words about it.</p>
</section>
    </article>

    <hr/>

<!-- /#posts-list -->

<div class="paginator">
<div class="paginator-newer">
        <a href="./index2.html">&larr; Newer Entries</a>
    &nbsp;
</div>
<div class="paginator-older">
    &nbsp;
</div>
</div>
    </section>
    <footer>
        Generated with Pelican 
    </footer>

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-38530232-1']);
_gaq.push(['_trackPageview']);
(function() {
 var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
 ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
 var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script>
</body>
</html>